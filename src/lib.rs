/* automatically generated by rust-bindgen */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
extern crate libusb_sys;

pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_VERS_1050: u32 = 0;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 101204;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 0;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const __CTERMID_DEFINED: u32 = 1;
pub const DC1394_CAPTURE_FLAGS_CHANNEL_ALLOC: u32 = 1;
pub const DC1394_CAPTURE_FLAGS_BANDWIDTH_ALLOC: u32 = 2;
pub const DC1394_CAPTURE_FLAGS_DEFAULT: u32 = 4;
pub const DC1394_CAPTURE_FLAGS_AUTO_ISO: u32 = 8;
pub const DC1394_QUERY_FROM_CAMERA: i32 = -1;
pub const DC1394_USE_MAX_AVAIL: i32 = -2;
pub const DC1394_USE_RECOMMENDED: i32 = -3;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __uint32_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub mod dc1394video_mode_t {
    #[doc = " Enumeration of video modes. Note that the notion of IIDC \"format\" is not present here, except in the format_7 name."]
    pub type Type = u32;
    pub const DC1394_VIDEO_MODE_160x120_YUV444: Type = 64;
    pub const DC1394_VIDEO_MODE_320x240_YUV422: Type = 65;
    pub const DC1394_VIDEO_MODE_640x480_YUV411: Type = 66;
    pub const DC1394_VIDEO_MODE_640x480_YUV422: Type = 67;
    pub const DC1394_VIDEO_MODE_640x480_RGB8: Type = 68;
    pub const DC1394_VIDEO_MODE_640x480_MONO8: Type = 69;
    pub const DC1394_VIDEO_MODE_640x480_MONO16: Type = 70;
    pub const DC1394_VIDEO_MODE_800x600_YUV422: Type = 71;
    pub const DC1394_VIDEO_MODE_800x600_RGB8: Type = 72;
    pub const DC1394_VIDEO_MODE_800x600_MONO8: Type = 73;
    pub const DC1394_VIDEO_MODE_1024x768_YUV422: Type = 74;
    pub const DC1394_VIDEO_MODE_1024x768_RGB8: Type = 75;
    pub const DC1394_VIDEO_MODE_1024x768_MONO8: Type = 76;
    pub const DC1394_VIDEO_MODE_800x600_MONO16: Type = 77;
    pub const DC1394_VIDEO_MODE_1024x768_MONO16: Type = 78;
    pub const DC1394_VIDEO_MODE_1280x960_YUV422: Type = 79;
    pub const DC1394_VIDEO_MODE_1280x960_RGB8: Type = 80;
    pub const DC1394_VIDEO_MODE_1280x960_MONO8: Type = 81;
    pub const DC1394_VIDEO_MODE_1600x1200_YUV422: Type = 82;
    pub const DC1394_VIDEO_MODE_1600x1200_RGB8: Type = 83;
    pub const DC1394_VIDEO_MODE_1600x1200_MONO8: Type = 84;
    pub const DC1394_VIDEO_MODE_1280x960_MONO16: Type = 85;
    pub const DC1394_VIDEO_MODE_1600x1200_MONO16: Type = 86;
    pub const DC1394_VIDEO_MODE_EXIF: Type = 87;
    pub const DC1394_VIDEO_MODE_FORMAT7_0: Type = 88;
    pub const DC1394_VIDEO_MODE_FORMAT7_1: Type = 89;
    pub const DC1394_VIDEO_MODE_FORMAT7_2: Type = 90;
    pub const DC1394_VIDEO_MODE_FORMAT7_3: Type = 91;
    pub const DC1394_VIDEO_MODE_FORMAT7_4: Type = 92;
    pub const DC1394_VIDEO_MODE_FORMAT7_5: Type = 93;
    pub const DC1394_VIDEO_MODE_FORMAT7_6: Type = 94;
    pub const DC1394_VIDEO_MODE_FORMAT7_7: Type = 95;
}
pub mod dc1394color_coding_t {
    #[doc = " Enumeration of colour codings. For details on the data format please read the IIDC specifications."]
    pub type Type = u32;
    pub const DC1394_COLOR_CODING_MONO8: Type = 352;
    pub const DC1394_COLOR_CODING_YUV411: Type = 353;
    pub const DC1394_COLOR_CODING_YUV422: Type = 354;
    pub const DC1394_COLOR_CODING_YUV444: Type = 355;
    pub const DC1394_COLOR_CODING_RGB8: Type = 356;
    pub const DC1394_COLOR_CODING_MONO16: Type = 357;
    pub const DC1394_COLOR_CODING_RGB16: Type = 358;
    pub const DC1394_COLOR_CODING_MONO16S: Type = 359;
    pub const DC1394_COLOR_CODING_RGB16S: Type = 360;
    pub const DC1394_COLOR_CODING_RAW8: Type = 361;
    pub const DC1394_COLOR_CODING_RAW16: Type = 362;
}
pub mod dc1394color_filter_t {
    #[doc = " RAW sensor filters. These elementary tiles tesselate the image plane in RAW modes. RGGB should be interpreted in 2D as"]
    #[doc = ""]
    #[doc = "    RG"]
    #[doc = "    GB"]
    #[doc = ""]
    #[doc = " and similarly for other filters."]
    pub type Type = u32;
    pub const DC1394_COLOR_FILTER_RGGB: Type = 512;
    pub const DC1394_COLOR_FILTER_GBRG: Type = 513;
    pub const DC1394_COLOR_FILTER_GRBG: Type = 514;
    pub const DC1394_COLOR_FILTER_BGGR: Type = 515;
}
pub mod dc1394byte_order_t {
    #[doc = " Byte order for YUV formats (may be expanded to RGB in the future)"]
    #[doc = ""]
    #[doc = " IIDC cameras always return data in UYVY order, but conversion functions can change this if requested."]
    pub type Type = u32;
    pub const DC1394_BYTE_ORDER_UYVY: Type = 800;
    pub const DC1394_BYTE_ORDER_YUYV: Type = 801;
}
#[doc = " A struct containing a list of color codings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dc1394color_codings_t {
    pub num: u32,
    pub codings: [dc1394color_coding_t::Type; 11usize],
}
#[test]
fn bindgen_test_layout_dc1394color_codings_t() {
    assert_eq!(
        ::std::mem::size_of::<dc1394color_codings_t>(),
        48usize,
        concat!("Size of: ", stringify!(dc1394color_codings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dc1394color_codings_t>(),
        4usize,
        concat!("Alignment of ", stringify!(dc1394color_codings_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394color_codings_t>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394color_codings_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394color_codings_t>())).codings as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394color_codings_t),
            "::",
            stringify!(codings)
        )
    );
}
#[doc = " A struct containing a list of video modes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dc1394video_modes_t {
    pub num: u32,
    pub modes: [dc1394video_mode_t::Type; 32usize],
}
#[test]
fn bindgen_test_layout_dc1394video_modes_t() {
    assert_eq!(
        ::std::mem::size_of::<dc1394video_modes_t>(),
        132usize,
        concat!("Size of: ", stringify!(dc1394video_modes_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dc1394video_modes_t>(),
        4usize,
        concat!("Alignment of ", stringify!(dc1394video_modes_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394video_modes_t>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394video_modes_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394video_modes_t>())).modes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394video_modes_t),
            "::",
            stringify!(modes)
        )
    );
}
pub mod dc1394bool_t {
    #[doc = " Yet another boolean data type"]
    pub type Type = u32;
    pub const DC1394_FALSE: Type = 0;
    pub const DC1394_TRUE: Type = 1;
}
pub mod dc1394switch_t {
    #[doc = " Yet another boolean data type, a bit more oriented towards electrical-engineers"]
    pub type Type = u32;
    pub const DC1394_OFF: Type = 0;
    pub const DC1394_ON: Type = 1;
}
pub mod dc1394error_t {
    #[doc = " Error codes returned by most libdc1394 functions."]
    #[doc = ""]
    #[doc = " General rule: 0 is success, negative denotes a problem."]
    pub type Type = i32;
    pub const DC1394_SUCCESS: Type = 0;
    pub const DC1394_FAILURE: Type = -1;
    pub const DC1394_NOT_A_CAMERA: Type = -2;
    pub const DC1394_FUNCTION_NOT_SUPPORTED: Type = -3;
    pub const DC1394_CAMERA_NOT_INITIALIZED: Type = -4;
    pub const DC1394_MEMORY_ALLOCATION_FAILURE: Type = -5;
    pub const DC1394_TAGGED_REGISTER_NOT_FOUND: Type = -6;
    pub const DC1394_NO_ISO_CHANNEL: Type = -7;
    pub const DC1394_NO_BANDWIDTH: Type = -8;
    pub const DC1394_IOCTL_FAILURE: Type = -9;
    pub const DC1394_CAPTURE_IS_NOT_SET: Type = -10;
    pub const DC1394_CAPTURE_IS_RUNNING: Type = -11;
    pub const DC1394_RAW1394_FAILURE: Type = -12;
    pub const DC1394_FORMAT7_ERROR_FLAG_1: Type = -13;
    pub const DC1394_FORMAT7_ERROR_FLAG_2: Type = -14;
    pub const DC1394_INVALID_ARGUMENT_VALUE: Type = -15;
    pub const DC1394_REQ_VALUE_OUTSIDE_RANGE: Type = -16;
    pub const DC1394_INVALID_FEATURE: Type = -17;
    pub const DC1394_INVALID_VIDEO_FORMAT: Type = -18;
    pub const DC1394_INVALID_VIDEO_MODE: Type = -19;
    pub const DC1394_INVALID_FRAMERATE: Type = -20;
    pub const DC1394_INVALID_TRIGGER_MODE: Type = -21;
    pub const DC1394_INVALID_TRIGGER_SOURCE: Type = -22;
    pub const DC1394_INVALID_ISO_SPEED: Type = -23;
    pub const DC1394_INVALID_IIDC_VERSION: Type = -24;
    pub const DC1394_INVALID_COLOR_CODING: Type = -25;
    pub const DC1394_INVALID_COLOR_FILTER: Type = -26;
    pub const DC1394_INVALID_CAPTURE_POLICY: Type = -27;
    pub const DC1394_INVALID_ERROR_CODE: Type = -28;
    pub const DC1394_INVALID_BAYER_METHOD: Type = -29;
    pub const DC1394_INVALID_VIDEO1394_DEVICE: Type = -30;
    pub const DC1394_INVALID_OPERATION_MODE: Type = -31;
    pub const DC1394_INVALID_TRIGGER_POLARITY: Type = -32;
    pub const DC1394_INVALID_FEATURE_MODE: Type = -33;
    pub const DC1394_INVALID_LOG_TYPE: Type = -34;
    pub const DC1394_INVALID_BYTE_ORDER: Type = -35;
    pub const DC1394_INVALID_STEREO_METHOD: Type = -36;
    pub const DC1394_BASLER_NO_MORE_SFF_CHUNKS: Type = -37;
    pub const DC1394_BASLER_CORRUPTED_SFF_CHUNK: Type = -38;
    pub const DC1394_BASLER_UNKNOWN_SFF_CHUNK: Type = -39;
}
pub mod dc1394log_t {
    #[doc = " Types of logging messages"]
    #[doc = ""]
    #[doc = " Three types exist:"]
    #[doc = " - ERROR for real, hard, unrecoverable errors that will result in the program terminating."]
    #[doc = " - WARNING for things that have gone wrong, but are not requiring a termination of the program."]
    #[doc = " - DEBUG for debug messages that can be very verbose but may help the developers to fix bugs."]
    pub type Type = u32;
    pub const DC1394_LOG_ERROR: Type = 768;
    pub const DC1394_LOG_WARNING: Type = 769;
    pub const DC1394_LOG_DEBUG: Type = 770;
}
extern "C" {
    #[doc = " dc1394_log_register_handler: register log handler for reporting error, warning or debug statements"]
    #[doc = " Passing NULL as argument turns off this log level."]
    #[doc = " @param [in] log_handler: pointer to a function which takes a character string as argument"]
    #[doc = "             type: the type of log"]
    #[doc = " @param [in] type: message type (\\a debug, \\a err or \\a warning)"]
    #[doc = " @param [in] message: log message"]
    pub fn dc1394_log_register_handler(
        type_: dc1394log_t::Type,
        log_handler: ::std::option::Option<
            unsafe extern "C" fn(
                type_: dc1394log_t::Type,
                log_handler: *const ::std::os::raw::c_char,
                user: *mut ::std::os::raw::c_void,
            ),
        >,
        user: *mut ::std::os::raw::c_void,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " dc1394_log_set_default_handler: set the log handler to the default handler"]
    #[doc = " At boot time, debug logging is OFF (handler is NULL). Using this function for the debug statements"]
    #[doc = " will start logging of debug statements usng the default handler."]
    pub fn dc1394_log_set_default_handler(type_: dc1394log_t::Type) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " dc1394_log_error: logs a fatal error condition to the registered facility"]
    #[doc = " This function shall be invoked if a fatal error condition is encountered."]
    #[doc = " The message passed as argument is delivered to the registered error reporting"]
    #[doc = " function registered before."]
    #[doc = " @param [in] format,...: error message to be logged, multiple arguments allowed (printf style)"]
    pub fn dc1394_log_error(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " dc1394_log_warning: logs a nonfatal error condition to the registered facility"]
    #[doc = " This function shall be invoked if a nonfatal error condition is encountered."]
    #[doc = " The message passed as argument is delivered to the registered warning reporting"]
    #[doc = " function registered before."]
    #[doc = " @param [in] format,...: warning message to be logged, multiple arguments allowed (printf style)"]
    pub fn dc1394_log_warning(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " dc1394_log_debug: logs a debug statement to the registered facility"]
    #[doc = " This function shall be invoked if a debug statement is to be logged."]
    #[doc = " The message passed as argument is delivered to the registered debug reporting"]
    #[doc = " function registered before ONLY IF the environment variable DC1394_DEBUG has been set before the"]
    #[doc = " program starts."]
    #[doc = " @param [in] format,...: debug statement to be logged, multiple arguments allowed (printf style)"]
    pub fn dc1394_log_debug(format: *const ::std::os::raw::c_char, ...);
}
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
pub mod dc1394iidc_version_t {
    #[doc = " List of IIDC versions"]
    #[doc = ""]
    #[doc = " Currently, the following versions exist: 1.04, 1.20, PTGREY, 1.30 and 1.31 (1.32 coming soon)"]
    #[doc = " Observing other versions means that there\'s a bug crawling somewhere."]
    pub type Type = u32;
    pub const DC1394_IIDC_VERSION_1_04: Type = 544;
    pub const DC1394_IIDC_VERSION_1_20: Type = 545;
    pub const DC1394_IIDC_VERSION_PTGREY: Type = 546;
    pub const DC1394_IIDC_VERSION_1_30: Type = 547;
    pub const DC1394_IIDC_VERSION_1_31: Type = 548;
    pub const DC1394_IIDC_VERSION_1_32: Type = 549;
    pub const DC1394_IIDC_VERSION_1_33: Type = 550;
    pub const DC1394_IIDC_VERSION_1_34: Type = 551;
    pub const DC1394_IIDC_VERSION_1_35: Type = 552;
    pub const DC1394_IIDC_VERSION_1_36: Type = 553;
    pub const DC1394_IIDC_VERSION_1_37: Type = 554;
    pub const DC1394_IIDC_VERSION_1_38: Type = 555;
    pub const DC1394_IIDC_VERSION_1_39: Type = 556;
}
pub mod dc1394power_class_t {
    #[doc = " Enumeration of power classes"]
    #[doc = ""]
    #[doc = " This is currently not used in libdc1394."]
    pub type Type = u32;
    pub const DC1394_POWER_CLASS_NONE: Type = 608;
    pub const DC1394_POWER_CLASS_PROV_MIN_15W: Type = 609;
    pub const DC1394_POWER_CLASS_PROV_MIN_30W: Type = 610;
    pub const DC1394_POWER_CLASS_PROV_MIN_45W: Type = 611;
    pub const DC1394_POWER_CLASS_USES_MAX_1W: Type = 612;
    pub const DC1394_POWER_CLASS_USES_MAX_3W: Type = 613;
    pub const DC1394_POWER_CLASS_USES_MAX_6W: Type = 614;
    pub const DC1394_POWER_CLASS_USES_MAX_10W: Type = 615;
}
pub mod dc1394phy_delay_t {
    #[doc = " Enumeration of PHY delays"]
    #[doc = ""]
    #[doc = " This is currently not used in libdc1394."]
    pub type Type = u32;
    pub const DC1394_PHY_DELAY_MAX_144_NS: Type = 640;
    pub const DC1394_PHY_DELAY_UNKNOWN_0: Type = 641;
    pub const DC1394_PHY_DELAY_UNKNOWN_1: Type = 642;
    pub const DC1394_PHY_DELAY_UNKNOWN_2: Type = 643;
}
#[doc = " Camera structure"]
#[doc = ""]
#[doc = " This structure represents the camera in libdc1394. It contains a number of useful static information, such as model/vendor names,"]
#[doc = " a few capabilities, some ROM offsets, a unique identifier, etc..."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dc1394_camera {
    pub guid: u64,
    pub unit: ::std::os::raw::c_int,
    pub unit_spec_ID: u32,
    pub unit_sw_version: u32,
    pub unit_sub_sw_version: u32,
    pub command_registers_base: u32,
    pub unit_directory: u32,
    pub unit_dependent_directory: u32,
    pub advanced_features_csr: u64,
    pub PIO_control_csr: u64,
    pub SIO_control_csr: u64,
    pub strobe_control_csr: u64,
    pub format7_csr: [u64; 8usize],
    pub iidc_version: dc1394iidc_version_t::Type,
    pub vendor: *mut ::std::os::raw::c_char,
    pub model: *mut ::std::os::raw::c_char,
    pub vendor_id: u32,
    pub model_id: u32,
    pub bmode_capable: dc1394bool_t::Type,
    pub one_shot_capable: dc1394bool_t::Type,
    pub multi_shot_capable: dc1394bool_t::Type,
    pub can_switch_on_off: dc1394bool_t::Type,
    pub has_vmode_error_status: dc1394bool_t::Type,
    pub has_feature_error_status: dc1394bool_t::Type,
    pub max_mem_channel: ::std::os::raw::c_int,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout___dc1394_camera() {
    assert_eq!(
        ::std::mem::size_of::<__dc1394_camera>(),
        200usize,
        concat!("Size of: ", stringify!(__dc1394_camera))
    );
    assert_eq!(
        ::std::mem::align_of::<__dc1394_camera>(),
        8usize,
        concat!("Alignment of ", stringify!(__dc1394_camera))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).guid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).unit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).unit_spec_ID as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(unit_spec_ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).unit_sw_version as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(unit_sw_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_camera>())).unit_sub_sw_version as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(unit_sub_sw_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_camera>())).command_registers_base as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(command_registers_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).unit_directory as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(unit_directory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_camera>())).unit_dependent_directory as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(unit_dependent_directory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_camera>())).advanced_features_csr as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(advanced_features_csr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).PIO_control_csr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(PIO_control_csr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).SIO_control_csr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(SIO_control_csr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_camera>())).strobe_control_csr as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(strobe_control_csr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).format7_csr as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(format7_csr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).iidc_version as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(iidc_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).vendor as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).model as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).vendor_id as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).model_id as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(model_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).bmode_capable as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(bmode_capable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_camera>())).one_shot_capable as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(one_shot_capable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_camera>())).multi_shot_capable as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(multi_shot_capable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_camera>())).can_switch_on_off as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(can_switch_on_off)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_camera>())).has_vmode_error_status as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(has_vmode_error_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_camera>())).has_feature_error_status as *const _
                as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(has_feature_error_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).max_mem_channel as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(max_mem_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_camera>())).flags as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_camera),
            "::",
            stringify!(flags)
        )
    );
}
pub type dc1394camera_t = __dc1394_camera;
#[doc = " A unique identifier for a functional camera unit"]
#[doc = ""]
#[doc = " Since a single camera can contain several functional units (think stereo cameras), the GUID is not enough to identify an IIDC camera."]
#[doc = " The unit number must also be used, hence this struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dc1394camera_id_t {
    pub unit: u16,
    pub guid: u64,
}
#[test]
fn bindgen_test_layout_dc1394camera_id_t() {
    assert_eq!(
        ::std::mem::size_of::<dc1394camera_id_t>(),
        16usize,
        concat!("Size of: ", stringify!(dc1394camera_id_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dc1394camera_id_t>(),
        8usize,
        concat!("Alignment of ", stringify!(dc1394camera_id_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394camera_id_t>())).unit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394camera_id_t),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394camera_id_t>())).guid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394camera_id_t),
            "::",
            stringify!(guid)
        )
    );
}
#[doc = " A list of cameras"]
#[doc = ""]
#[doc = " Usually returned by dc1394_camera_eumerate()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dc1394camera_list_t {
    pub num: u32,
    pub ids: *mut dc1394camera_id_t,
}
#[test]
fn bindgen_test_layout___dc1394camera_list_t() {
    assert_eq!(
        ::std::mem::size_of::<__dc1394camera_list_t>(),
        16usize,
        concat!("Size of: ", stringify!(__dc1394camera_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__dc1394camera_list_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__dc1394camera_list_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394camera_list_t>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394camera_list_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394camera_list_t>())).ids as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394camera_list_t),
            "::",
            stringify!(ids)
        )
    );
}
pub type dc1394camera_list_t = __dc1394camera_list_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dc1394_t {
    _unused: [u8; 0],
}
pub type dc1394_t = __dc1394_t;
extern "C" {
    #[doc = " Creates a new context in which cameras can be searched and used. This should be called before using any other libdc1394 function."]
    pub fn dc1394_new() -> *mut dc1394_t;
}
extern "C" {
    #[doc = " Liberates a context. Last function to use in your program. After this, no libdc1394 function can be used."]
    pub fn dc1394_free(dc1394: *mut dc1394_t);
}
extern "C" {
    #[doc = " Sets and gets the broadcast flag of a camera. If the broadcast flag is set,"]
    #[doc = " all devices on the bus will execute the command. Useful to sync ISO start"]
    #[doc = " commands or setting a bunch of cameras at the same time. Broadcast only works"]
    #[doc = " with identical devices (brand/model). If the devices are not identical your"]
    #[doc = " mileage may vary. Some cameras may not answer broadcast commands at all. Also,"]
    #[doc = " this only works with cameras on the SAME bus (IOW, the same port)."]
    pub fn dc1394_camera_set_broadcast(
        camera: *mut dc1394camera_t,
        pwr: dc1394bool_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    pub fn dc1394_camera_get_broadcast(
        camera: *mut dc1394camera_t,
        pwr: *mut dc1394bool_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Resets the IEEE1394 bus which camera is attached to.  Calling this function is"]
    #[doc = " \"rude\" to other devices because it causes them to re-enumerate on the bus and"]
    #[doc = " may cause a temporary disruption in their current activities.  Thus, use it"]
    #[doc = " sparingly.  Its primary use is if a program shuts down uncleanly and needs to"]
    #[doc = " free leftover ISO channels or bandwidth.  A bus reset will free those things"]
    #[doc = " as a side effect."]
    pub fn dc1394_reset_bus(camera: *mut dc1394camera_t) -> dc1394error_t::Type;
}
extern "C" {
    pub fn dc1394_read_cycle_timer(
        camera: *mut dc1394camera_t,
        cycle_timer: *mut u32,
        local_time: *mut u64,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the IEEE 1394 node ID of the camera."]
    pub fn dc1394_camera_get_node(
        camera: *mut dc1394camera_t,
        node: *mut u32,
        generation: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Returns the list of cameras available on the computer. If present, multiple cards will be probed"]
    pub fn dc1394_camera_enumerate(
        dc1394: *mut dc1394_t,
        list: *mut *mut dc1394camera_list_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Frees the memory allocated in dc1394_enumerate_cameras for the camera list"]
    pub fn dc1394_camera_free_list(list: *mut dc1394camera_list_t);
}
extern "C" {
    #[doc = " Create a new camera based on a GUID (Global Unique IDentifier)"]
    pub fn dc1394_camera_new(dc1394: *mut dc1394_t, guid: u64) -> *mut dc1394camera_t;
}
extern "C" {
    #[doc = " Create a new camera based on a GUID and a unit number (for multi-unit cameras)"]
    pub fn dc1394_camera_new_unit(
        dc1394: *mut dc1394_t,
        guid: u64,
        unit: ::std::os::raw::c_int,
    ) -> *mut dc1394camera_t;
}
extern "C" {
    #[doc = " Frees a camera structure"]
    pub fn dc1394_camera_free(camera: *mut dc1394camera_t);
}
extern "C" {
    #[doc = " Print various camera information, such as GUID, vendor, model, supported IIDC specs, etc..."]
    pub fn dc1394_camera_print_info(
        camera: *mut dc1394camera_t,
        fd: *mut FILE,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Returns a pointer to a string identifying the platform for the cameras. Platforms strings are:"]
    #[doc = " juju, linux, macosx, windows, usb"]
    pub fn dc1394_camera_get_platform_string(
        camera: *mut dc1394camera_t,
        platform: *mut *const ::std::os::raw::c_char,
    ) -> dc1394error_t::Type;
}
pub mod dc1394trigger_mode_t {
    #[doc = " Enumeration of trigger modes"]
    pub type Type = u32;
    pub const DC1394_TRIGGER_MODE_0: Type = 384;
    pub const DC1394_TRIGGER_MODE_1: Type = 385;
    pub const DC1394_TRIGGER_MODE_2: Type = 386;
    pub const DC1394_TRIGGER_MODE_3: Type = 387;
    pub const DC1394_TRIGGER_MODE_4: Type = 388;
    pub const DC1394_TRIGGER_MODE_5: Type = 389;
    pub const DC1394_TRIGGER_MODE_14: Type = 390;
    pub const DC1394_TRIGGER_MODE_15: Type = 391;
}
pub mod dc1394feature_t {
    #[doc = " Enumeration of camera features"]
    pub type Type = u32;
    pub const DC1394_FEATURE_BRIGHTNESS: Type = 416;
    pub const DC1394_FEATURE_EXPOSURE: Type = 417;
    pub const DC1394_FEATURE_SHARPNESS: Type = 418;
    pub const DC1394_FEATURE_WHITE_BALANCE: Type = 419;
    pub const DC1394_FEATURE_HUE: Type = 420;
    pub const DC1394_FEATURE_SATURATION: Type = 421;
    pub const DC1394_FEATURE_GAMMA: Type = 422;
    pub const DC1394_FEATURE_SHUTTER: Type = 423;
    pub const DC1394_FEATURE_GAIN: Type = 424;
    pub const DC1394_FEATURE_IRIS: Type = 425;
    pub const DC1394_FEATURE_FOCUS: Type = 426;
    pub const DC1394_FEATURE_TEMPERATURE: Type = 427;
    pub const DC1394_FEATURE_TRIGGER: Type = 428;
    pub const DC1394_FEATURE_TRIGGER_DELAY: Type = 429;
    pub const DC1394_FEATURE_WHITE_SHADING: Type = 430;
    pub const DC1394_FEATURE_FRAME_RATE: Type = 431;
    pub const DC1394_FEATURE_ZOOM: Type = 432;
    pub const DC1394_FEATURE_PAN: Type = 433;
    pub const DC1394_FEATURE_TILT: Type = 434;
    pub const DC1394_FEATURE_OPTICAL_FILTER: Type = 435;
    pub const DC1394_FEATURE_CAPTURE_SIZE: Type = 436;
    pub const DC1394_FEATURE_CAPTURE_QUALITY: Type = 437;
}
pub mod dc1394trigger_source_t {
    #[doc = " Enumeration of trigger sources"]
    pub type Type = u32;
    pub const DC1394_TRIGGER_SOURCE_0: Type = 576;
    pub const DC1394_TRIGGER_SOURCE_1: Type = 577;
    pub const DC1394_TRIGGER_SOURCE_2: Type = 578;
    pub const DC1394_TRIGGER_SOURCE_3: Type = 579;
    pub const DC1394_TRIGGER_SOURCE_SOFTWARE: Type = 580;
}
pub mod dc1394trigger_polarity_t {
    #[doc = " External trigger polarity"]
    pub type Type = u32;
    pub const DC1394_TRIGGER_ACTIVE_LOW: Type = 704;
    pub const DC1394_TRIGGER_ACTIVE_HIGH: Type = 705;
}
pub mod dc1394feature_mode_t {
    #[doc = " Control modes for a feature (excl. absolute control)"]
    pub type Type = u32;
    pub const DC1394_FEATURE_MODE_MANUAL: Type = 736;
    pub const DC1394_FEATURE_MODE_AUTO: Type = 737;
    pub const DC1394_FEATURE_MODE_ONE_PUSH_AUTO: Type = 738;
}
#[doc = " List of feature modes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dc1394feature_modes_t {
    pub num: u32,
    pub modes: [dc1394feature_mode_t::Type; 3usize],
}
#[test]
fn bindgen_test_layout_dc1394feature_modes_t() {
    assert_eq!(
        ::std::mem::size_of::<dc1394feature_modes_t>(),
        16usize,
        concat!("Size of: ", stringify!(dc1394feature_modes_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dc1394feature_modes_t>(),
        4usize,
        concat!("Alignment of ", stringify!(dc1394feature_modes_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394feature_modes_t>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394feature_modes_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394feature_modes_t>())).modes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394feature_modes_t),
            "::",
            stringify!(modes)
        )
    );
}
#[doc = " List of trigger modes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dc1394trigger_modes_t {
    pub num: u32,
    pub modes: [dc1394trigger_mode_t::Type; 8usize],
}
#[test]
fn bindgen_test_layout_dc1394trigger_modes_t() {
    assert_eq!(
        ::std::mem::size_of::<dc1394trigger_modes_t>(),
        36usize,
        concat!("Size of: ", stringify!(dc1394trigger_modes_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dc1394trigger_modes_t>(),
        4usize,
        concat!("Alignment of ", stringify!(dc1394trigger_modes_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394trigger_modes_t>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394trigger_modes_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394trigger_modes_t>())).modes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394trigger_modes_t),
            "::",
            stringify!(modes)
        )
    );
}
#[doc = " List of trigger sources"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dc1394trigger_sources_t {
    pub num: u32,
    pub sources: [dc1394trigger_source_t::Type; 5usize],
}
#[test]
fn bindgen_test_layout_dc1394trigger_sources_t() {
    assert_eq!(
        ::std::mem::size_of::<dc1394trigger_sources_t>(),
        24usize,
        concat!("Size of: ", stringify!(dc1394trigger_sources_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dc1394trigger_sources_t>(),
        4usize,
        concat!("Alignment of ", stringify!(dc1394trigger_sources_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394trigger_sources_t>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394trigger_sources_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394trigger_sources_t>())).sources as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394trigger_sources_t),
            "::",
            stringify!(sources)
        )
    );
}
#[doc = " A structure containing all information about a feature."]
#[doc = ""]
#[doc = " Some fields are only valid for some features (e.g. trigger, white balance,...)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dc1394feature_info_t_struct {
    pub id: dc1394feature_t::Type,
    pub available: dc1394bool_t::Type,
    pub absolute_capable: dc1394bool_t::Type,
    pub readout_capable: dc1394bool_t::Type,
    pub on_off_capable: dc1394bool_t::Type,
    pub polarity_capable: dc1394bool_t::Type,
    pub is_on: dc1394switch_t::Type,
    pub current_mode: dc1394feature_mode_t::Type,
    pub modes: dc1394feature_modes_t,
    pub trigger_modes: dc1394trigger_modes_t,
    pub trigger_mode: dc1394trigger_mode_t::Type,
    pub trigger_polarity: dc1394trigger_polarity_t::Type,
    pub trigger_sources: dc1394trigger_sources_t,
    pub trigger_source: dc1394trigger_source_t::Type,
    pub min: u32,
    pub max: u32,
    pub value: u32,
    pub BU_value: u32,
    pub RV_value: u32,
    pub B_value: u32,
    pub R_value: u32,
    pub G_value: u32,
    pub target_value: u32,
    pub abs_control: dc1394switch_t::Type,
    pub abs_value: f32,
    pub abs_max: f32,
    pub abs_min: f32,
}
#[test]
fn bindgen_test_layout___dc1394feature_info_t_struct() {
    assert_eq!(
        ::std::mem::size_of::<__dc1394feature_info_t_struct>(),
        172usize,
        concat!("Size of: ", stringify!(__dc1394feature_info_t_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__dc1394feature_info_t_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(__dc1394feature_info_t_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).available as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(available)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).absolute_capable as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(absolute_capable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).readout_capable as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(readout_capable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).on_off_capable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(on_off_capable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).polarity_capable as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(polarity_capable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).is_on as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(is_on)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).current_mode as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(current_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).modes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(modes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).trigger_modes as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(trigger_modes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).trigger_mode as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(trigger_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).trigger_polarity as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(trigger_polarity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).trigger_sources as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(trigger_sources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).trigger_source as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(trigger_source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).min as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).max as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).value as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).BU_value as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(BU_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).RV_value as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(RV_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).B_value as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(B_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).R_value as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(R_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).G_value as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(G_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).target_value as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(target_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).abs_control as *const _
                as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(abs_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).abs_value as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(abs_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).abs_max as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(abs_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394feature_info_t_struct>())).abs_min as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394feature_info_t_struct),
            "::",
            stringify!(abs_min)
        )
    );
}
pub type dc1394feature_info_t = __dc1394feature_info_t_struct;
#[doc = " The list of features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dc1394featureset_t {
    pub feature: [dc1394feature_info_t; 22usize],
}
#[test]
fn bindgen_test_layout___dc1394featureset_t() {
    assert_eq!(
        ::std::mem::size_of::<__dc1394featureset_t>(),
        3784usize,
        concat!("Size of: ", stringify!(__dc1394featureset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__dc1394featureset_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__dc1394featureset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394featureset_t>())).feature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394featureset_t),
            "::",
            stringify!(feature)
        )
    );
}
pub type dc1394featureset_t = __dc1394featureset_t;
extern "C" {
    #[doc = " Collects the available features for the camera described by node and stores them in features."]
    pub fn dc1394_feature_get_all(
        camera: *mut dc1394camera_t,
        features: *mut dc1394featureset_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Stores the bounds and options associated with the feature described by feature->feature_id"]
    pub fn dc1394_feature_get(
        camera: *mut dc1394camera_t,
        feature: *mut dc1394feature_info_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Displays the bounds and options of the given feature"]
    pub fn dc1394_feature_print(
        feature: *mut dc1394feature_info_t,
        fd: *mut FILE,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Displays the bounds and options of every feature supported by the camera"]
    pub fn dc1394_feature_print_all(
        features: *mut dc1394featureset_t,
        fd: *mut FILE,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the whitebalance values"]
    pub fn dc1394_feature_whitebalance_get_value(
        camera: *mut dc1394camera_t,
        u_b_value: *mut u32,
        v_r_value: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the whitebalance values"]
    pub fn dc1394_feature_whitebalance_set_value(
        camera: *mut dc1394camera_t,
        u_b_value: u32,
        v_r_value: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the temperature values (target and current)"]
    pub fn dc1394_feature_temperature_get_value(
        camera: *mut dc1394camera_t,
        target_temperature: *mut u32,
        temperature: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the temperature values (target only) FIXME: COULD BE DROPPED? already in the standard feature_set_value()?"]
    pub fn dc1394_feature_temperature_set_value(
        camera: *mut dc1394camera_t,
        target_temperature: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the white shading values"]
    pub fn dc1394_feature_whiteshading_get_value(
        camera: *mut dc1394camera_t,
        r_value: *mut u32,
        g_value: *mut u32,
        b_value: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the white shading values"]
    pub fn dc1394_feature_whiteshading_set_value(
        camera: *mut dc1394camera_t,
        r_value: u32,
        g_value: u32,
        b_value: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the value of a feature"]
    pub fn dc1394_feature_get_value(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        value: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the value of a feature"]
    pub fn dc1394_feature_set_value(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        value: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Tells whether a feature is present or not"]
    pub fn dc1394_feature_is_present(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        value: *mut dc1394bool_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Tells whether a feature is readable or not"]
    pub fn dc1394_feature_is_readable(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        value: *mut dc1394bool_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the boundaries of a feature"]
    pub fn dc1394_feature_get_boundaries(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        min: *mut u32,
        max: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Tells whether a feature is switcheable or not (ON/OFF)"]
    pub fn dc1394_feature_is_switchable(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        value: *mut dc1394bool_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the power status of a feature (ON or OFF)"]
    pub fn dc1394_feature_get_power(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        pwr: *mut dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the power status of a feature (ON or OFF)"]
    pub fn dc1394_feature_set_power(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        pwr: dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the list of control modes for a feature (manual, auto, etc...)"]
    pub fn dc1394_feature_get_modes(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        modes: *mut dc1394feature_modes_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current control modes for a feature"]
    pub fn dc1394_feature_get_mode(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        mode: *mut dc1394feature_mode_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the current control modes for a feature"]
    pub fn dc1394_feature_set_mode(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        mode: dc1394feature_mode_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Tells whether a feature can be controlled in absolute mode"]
    pub fn dc1394_feature_has_absolute_control(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        value: *mut dc1394bool_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the absolute boundaries of a feature"]
    pub fn dc1394_feature_get_absolute_boundaries(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        min: *mut f32,
        max: *mut f32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the absolute value of a feature"]
    pub fn dc1394_feature_get_absolute_value(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        value: *mut f32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the absolute value of a feature"]
    pub fn dc1394_feature_set_absolute_value(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        value: f32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the status of absolute control of a feature"]
    pub fn dc1394_feature_get_absolute_control(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        pwr: *mut dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the feature in absolute control mode (ON/OFF)"]
    pub fn dc1394_feature_set_absolute_control(
        camera: *mut dc1394camera_t,
        feature: dc1394feature_t::Type,
        pwr: dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the polarity of the external trigger"]
    pub fn dc1394_external_trigger_set_polarity(
        camera: *mut dc1394camera_t,
        polarity: dc1394trigger_polarity_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the polarity of the external trigger"]
    pub fn dc1394_external_trigger_get_polarity(
        camera: *mut dc1394camera_t,
        polarity: *mut dc1394trigger_polarity_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Tells whether the external trigger can change its polarity or not."]
    pub fn dc1394_external_trigger_has_polarity(
        camera: *mut dc1394camera_t,
        polarity_capable: *mut dc1394bool_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Switch between internal and external trigger"]
    pub fn dc1394_external_trigger_set_power(
        camera: *mut dc1394camera_t,
        pwr: dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the status of the external trigger"]
    pub fn dc1394_external_trigger_get_power(
        camera: *mut dc1394camera_t,
        pwr: *mut dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the external trigger mode"]
    pub fn dc1394_external_trigger_set_mode(
        camera: *mut dc1394camera_t,
        mode: dc1394trigger_mode_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the external trigger mode"]
    pub fn dc1394_external_trigger_get_mode(
        camera: *mut dc1394camera_t,
        mode: *mut dc1394trigger_mode_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the external trigger source"]
    pub fn dc1394_external_trigger_set_source(
        camera: *mut dc1394camera_t,
        source: dc1394trigger_source_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the external trigger source"]
    pub fn dc1394_external_trigger_get_source(
        camera: *mut dc1394camera_t,
        source: *mut dc1394trigger_source_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the list of available external trigger source"]
    pub fn dc1394_external_trigger_get_supported_sources(
        camera: *mut dc1394camera_t,
        sources: *mut dc1394trigger_sources_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Turn software trigger on or off"]
    pub fn dc1394_software_trigger_set_power(
        camera: *mut dc1394camera_t,
        pwr: dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the state of software trigger"]
    pub fn dc1394_software_trigger_get_power(
        camera: *mut dc1394camera_t,
        pwr: *mut dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sends a quadlet on the PIO (output)"]
    pub fn dc1394_pio_set(camera: *mut dc1394camera_t, value: u32) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current quadlet at the PIO (input)"]
    pub fn dc1394_pio_get(camera: *mut dc1394camera_t, value: *mut u32) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " reset a camera to factory default settings"]
    pub fn dc1394_camera_reset(camera: *mut dc1394camera_t) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " turn a camera on or off"]
    pub fn dc1394_camera_set_power(
        camera: *mut dc1394camera_t,
        pwr: dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Download a camera setup from the memory."]
    pub fn dc1394_memory_busy(
        camera: *mut dc1394camera_t,
        value: *mut dc1394bool_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Uploads a camera setup in the memory."]
    #[doc = ""]
    #[doc = " Note that this operation can only be performed a certain number of"]
    #[doc = " times for a given camera, as it requires reprogramming of an EEPROM."]
    pub fn dc1394_memory_save(camera: *mut dc1394camera_t, channel: u32) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Tells whether the writing of the camera setup in memory is finished or not."]
    pub fn dc1394_memory_load(camera: *mut dc1394camera_t, channel: u32) -> dc1394error_t::Type;
}
pub mod dc1394speed_t {
    #[doc = " Enumeration of iso data speeds"]
    #[doc = ""]
    #[doc = " Most (if not all) cameras are compatible with 400Mbps speed. Only older cameras (pre-1999) may still only work at sub-400"]
    #[doc = " speeds. However, speeds lower than 400Mbps are still useful: they can be used for longer distances (e.g. 10m cables)."]
    #[doc = " Speeds over 400Mbps are only available in \"B\" mode (DC1394_OPERATION_MODE_1394B)."]
    pub type Type = u32;
    pub const DC1394_ISO_SPEED_100: Type = 0;
    pub const DC1394_ISO_SPEED_200: Type = 1;
    pub const DC1394_ISO_SPEED_400: Type = 2;
    pub const DC1394_ISO_SPEED_800: Type = 3;
    pub const DC1394_ISO_SPEED_1600: Type = 4;
    pub const DC1394_ISO_SPEED_3200: Type = 5;
}
pub mod dc1394framerate_t {
    #[doc = " Enumeration of video framerates"]
    #[doc = ""]
    #[doc = " This enumeration is used for non-Format_7 modes. The framerate can be lower than expected if the exposure time is longer"]
    #[doc = " than the requested frame period. Framerate can be controlled in a number of other ways: framerate feature, external trigger,"]
    #[doc = " software trigger, shutter throttling and packet size (Format_7)"]
    pub type Type = u32;
    pub const DC1394_FRAMERATE_1_875: Type = 32;
    pub const DC1394_FRAMERATE_3_75: Type = 33;
    pub const DC1394_FRAMERATE_7_5: Type = 34;
    pub const DC1394_FRAMERATE_15: Type = 35;
    pub const DC1394_FRAMERATE_30: Type = 36;
    pub const DC1394_FRAMERATE_60: Type = 37;
    pub const DC1394_FRAMERATE_120: Type = 38;
    pub const DC1394_FRAMERATE_240: Type = 39;
}
pub mod dc1394operation_mode_t {
    #[doc = " Operation modes"]
    #[doc = ""]
    #[doc = " Two operation modes exist: the legacy and most common 1394a, and the newer 1394B. The latter allows speeds over 400Mbps, but"]
    #[doc = " can also be used at other speeds."]
    pub type Type = u32;
    pub const DC1394_OPERATION_MODE_LEGACY: Type = 480;
    pub const DC1394_OPERATION_MODE_1394B: Type = 481;
}
#[doc = " List of framerates"]
#[doc = ""]
#[doc = " dc1394framerates_t contains a list of available framerates for a particular video mode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dc1394framerates_t {
    pub num: u32,
    pub framerates: [dc1394framerate_t::Type; 8usize],
}
#[test]
fn bindgen_test_layout_dc1394framerates_t() {
    assert_eq!(
        ::std::mem::size_of::<dc1394framerates_t>(),
        36usize,
        concat!("Size of: ", stringify!(dc1394framerates_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dc1394framerates_t>(),
        4usize,
        concat!("Alignment of ", stringify!(dc1394framerates_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394framerates_t>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394framerates_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dc1394framerates_t>())).framerates as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dc1394framerates_t),
            "::",
            stringify!(framerates)
        )
    );
}
#[doc = " Video frame structure."]
#[doc = ""]
#[doc = " dc1394video_frame_t is the structure returned by the capture functions. It contains the captured image as well as a number of"]
#[doc = " information."]
#[doc = ""]
#[doc = " In general this structure should be calloc\'ed so that members such as \"allocated size\""]
#[doc = " are properly set to zero. Don\'t forget to free the \"image\" member before freeing the struct itself."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dc1394_video_frame {
    pub image: *mut ::std::os::raw::c_uchar,
    pub size: [u32; 2usize],
    pub position: [u32; 2usize],
    pub color_coding: dc1394color_coding_t::Type,
    pub color_filter: dc1394color_filter_t::Type,
    pub yuv_byte_order: u32,
    pub data_depth: u32,
    pub stride: u32,
    pub video_mode: dc1394video_mode_t::Type,
    pub total_bytes: u64,
    pub image_bytes: u32,
    pub padding_bytes: u32,
    pub packet_size: u32,
    pub packets_per_frame: u32,
    pub timestamp: u64,
    pub frames_behind: u32,
    pub camera: *mut dc1394camera_t,
    pub id: u32,
    pub allocated_image_bytes: u64,
    pub little_endian: dc1394bool_t::Type,
    pub data_in_padding: dc1394bool_t::Type,
}
#[test]
fn bindgen_test_layout___dc1394_video_frame() {
    assert_eq!(
        ::std::mem::size_of::<__dc1394_video_frame>(),
        120usize,
        concat!("Size of: ", stringify!(__dc1394_video_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__dc1394_video_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__dc1394_video_frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_video_frame>())).image as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_video_frame>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_video_frame>())).position as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_video_frame>())).color_coding as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(color_coding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_video_frame>())).color_filter as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(color_filter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_video_frame>())).yuv_byte_order as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(yuv_byte_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_video_frame>())).data_depth as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(data_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_video_frame>())).stride as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_video_frame>())).video_mode as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(video_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_video_frame>())).total_bytes as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(total_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_video_frame>())).image_bytes as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(image_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_video_frame>())).padding_bytes as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(padding_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_video_frame>())).packet_size as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(packet_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_video_frame>())).packets_per_frame as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(packets_per_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_video_frame>())).timestamp as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_video_frame>())).frames_behind as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(frames_behind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_video_frame>())).camera as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(camera)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394_video_frame>())).id as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_video_frame>())).allocated_image_bytes as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(allocated_image_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_video_frame>())).little_endian as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(little_endian)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394_video_frame>())).data_in_padding as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394_video_frame),
            "::",
            stringify!(data_in_padding)
        )
    );
}
pub type dc1394video_frame_t = __dc1394_video_frame;
extern "C" {
    #[doc = " Gets a list of video modes supported by the camera."]
    pub fn dc1394_video_get_supported_modes(
        camera: *mut dc1394camera_t,
        video_modes: *mut dc1394video_modes_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets a list of supported video framerates for a given video mode. This function only works with non-scalable formats."]
    pub fn dc1394_video_get_supported_framerates(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        framerates: *mut dc1394framerates_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current framerate. This is meaningful only if the video mode is not scalable."]
    pub fn dc1394_video_get_framerate(
        camera: *mut dc1394camera_t,
        framerate: *mut dc1394framerate_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the current framerate. This is meaningful only if the video mode is not scalable."]
    pub fn dc1394_video_set_framerate(
        camera: *mut dc1394camera_t,
        framerate: dc1394framerate_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current vide mode."]
    pub fn dc1394_video_get_mode(
        camera: *mut dc1394camera_t,
        video_mode: *mut dc1394video_mode_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the current vide mode."]
    pub fn dc1394_video_set_mode(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current operation mode."]
    pub fn dc1394_video_get_operation_mode(
        camera: *mut dc1394camera_t,
        mode: *mut dc1394operation_mode_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the current operation mode."]
    pub fn dc1394_video_set_operation_mode(
        camera: *mut dc1394camera_t,
        mode: dc1394operation_mode_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current ISO speed."]
    pub fn dc1394_video_get_iso_speed(
        camera: *mut dc1394camera_t,
        speed: *mut dc1394speed_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the current ISO speed. Speeds over 400Mbps require 1394B."]
    pub fn dc1394_video_set_iso_speed(
        camera: *mut dc1394camera_t,
        speed: dc1394speed_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current ISO channel"]
    pub fn dc1394_video_get_iso_channel(
        camera: *mut dc1394camera_t,
        channel: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the current ISO channel"]
    pub fn dc1394_video_set_iso_channel(
        camera: *mut dc1394camera_t,
        channel: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current data depth, in bits. Only meaningful for 16bpp video modes (RAW16, RGB48, MONO16,...)"]
    pub fn dc1394_video_get_data_depth(
        camera: *mut dc1394camera_t,
        depth: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Starts/stops the isochronous data transmission. In other words, use this to control the image flow."]
    pub fn dc1394_video_set_transmission(
        camera: *mut dc1394camera_t,
        pwr: dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the status of the video transmission"]
    pub fn dc1394_video_get_transmission(
        camera: *mut dc1394camera_t,
        pwr: *mut dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Turns one-shot mode on or off"]
    pub fn dc1394_video_set_one_shot(
        camera: *mut dc1394camera_t,
        pwr: dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the status of the one-shot mode."]
    pub fn dc1394_video_get_one_shot(
        camera: *mut dc1394camera_t,
        is_on: *mut dc1394bool_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Turns multishot mode on or off"]
    pub fn dc1394_video_set_multi_shot(
        camera: *mut dc1394camera_t,
        numFrames: u32,
        pwr: dc1394switch_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the status of the multi-shot mode."]
    pub fn dc1394_video_get_multi_shot(
        camera: *mut dc1394camera_t,
        is_on: *mut dc1394bool_t::Type,
        numFrames: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the bandwidth usage of a camera."]
    #[doc = ""]
    #[doc = " This function returns the bandwidth that is used by the camera *IF* ISO was ON."]
    #[doc = " The returned value is in bandwidth units. The 1394 bus has 4915 bandwidth units"]
    #[doc = " available per cycle. Each unit corresponds to the time it takes to send one"]
    #[doc = " quadlet at ISO speed S1600. The bandwidth usage at S400 is thus four times the"]
    #[doc = " number of quadlets per packet. Thanks to Krisitian Hogsberg for clarifying this."]
    pub fn dc1394_video_get_bandwidth_usage(
        camera: *mut dc1394camera_t,
        bandwidth: *mut u32,
    ) -> dc1394error_t::Type;
}
pub mod dc1394capture_policy_t {
    #[doc = " The capture policy."]
    #[doc = ""]
    #[doc = " Can be blocking (wait for a frame forever) or polling (returns if no frames is in the ring buffer)"]
    pub type Type = u32;
    pub const DC1394_CAPTURE_POLICY_WAIT: Type = 672;
    pub const DC1394_CAPTURE_POLICY_POLL: Type = 673;
}
#[doc = " typedef for the callback param for dc1394_capture_set_callback"]
pub type dc1394capture_callback_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut dc1394camera_t, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Setup the capture, using a ring buffer of a certain size (num_dma_buffers) and certain options (flags)"]
    pub fn dc1394_capture_setup(
        camera: *mut dc1394camera_t,
        num_dma_buffers: u32,
        flags: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Stop the capture"]
    pub fn dc1394_capture_stop(camera: *mut dc1394camera_t) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets a file descriptor to be used for select(). Must be called after dc1394_capture_setup()."]
    pub fn dc1394_capture_get_fileno(camera: *mut dc1394camera_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Captures a video frame. The returned struct contains the image buffer, among others. This image buffer SHALL NOT be freed, as it represents an area"]
    #[doc = " in the memory that belongs to the system."]
    pub fn dc1394_capture_dequeue(
        camera: *mut dc1394camera_t,
        policy: dc1394capture_policy_t::Type,
        frame: *mut *mut dc1394video_frame_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Returns a frame to the ring buffer once it has been used."]
    pub fn dc1394_capture_enqueue(
        camera: *mut dc1394camera_t,
        frame: *mut dc1394video_frame_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Returns DC1394_TRUE if the given frame (previously dequeued) has been"]
    #[doc = " detected to be corrupt (missing data, corrupted data, overrun buffer, etc.)."]
    #[doc = " Note that certain types of corruption may go undetected in which case"]
    #[doc = " DC1394_FALSE will be returned.  The ability to detect corruption also"]
    #[doc = " varies between platforms.  Note that corrupt frames still need to be"]
    #[doc = " enqueued with dc1394_capture_enqueue() when no longer needed by the user."]
    pub fn dc1394_capture_is_frame_corrupt(
        camera: *mut dc1394camera_t,
        frame: *mut dc1394video_frame_t,
    ) -> dc1394bool_t::Type;
}
extern "C" {
    #[doc = " Set a callback if supported by the platform (OS X only for now)."]
    pub fn dc1394_capture_set_callback(
        camera: *mut dc1394camera_t,
        callback: dc1394capture_callback_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub mod dc1394bayer_method_t {
    #[doc = " A list of de-mosaicing techniques for Bayer-patterns."]
    #[doc = ""]
    #[doc = " The speed of the techniques can vary greatly, as well as their quality."]
    pub type Type = u32;
    pub const DC1394_BAYER_METHOD_NEAREST: Type = 0;
    pub const DC1394_BAYER_METHOD_SIMPLE: Type = 1;
    pub const DC1394_BAYER_METHOD_BILINEAR: Type = 2;
    pub const DC1394_BAYER_METHOD_HQLINEAR: Type = 3;
    pub const DC1394_BAYER_METHOD_DOWNSAMPLE: Type = 4;
    pub const DC1394_BAYER_METHOD_EDGESENSE: Type = 5;
    pub const DC1394_BAYER_METHOD_VNG: Type = 6;
    pub const DC1394_BAYER_METHOD_AHD: Type = 7;
}
pub mod dc1394stereo_method_t {
    #[doc = " A list of known stereo-in-normal-video modes used by manufacturers like Point Grey Research and Videre Design."]
    pub type Type = u32;
    pub const DC1394_STEREO_METHOD_INTERLACED: Type = 0;
    pub const DC1394_STEREO_METHOD_FIELD: Type = 1;
}
extern "C" {
    #[doc = " Converts an image buffer to YUV422"]
    pub fn dc1394_convert_to_YUV422(
        src: *mut u8,
        dest: *mut u8,
        width: u32,
        height: u32,
        byte_order: u32,
        source_coding: dc1394color_coding_t::Type,
        bits: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Converts an image buffer to MONO8"]
    pub fn dc1394_convert_to_MONO8(
        src: *mut u8,
        dest: *mut u8,
        width: u32,
        height: u32,
        byte_order: u32,
        source_coding: dc1394color_coding_t::Type,
        bits: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Converts an image buffer to RGB8"]
    pub fn dc1394_convert_to_RGB8(
        src: *mut u8,
        dest: *mut u8,
        width: u32,
        height: u32,
        byte_order: u32,
        source_coding: dc1394color_coding_t::Type,
        bits: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " changes a 16bit stereo image (8bit/channel) into two 8bit images on top of each other"]
    pub fn dc1394_deinterlace_stereo(
        src: *mut u8,
        dest: *mut u8,
        width: u32,
        height: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Perform de-mosaicing on an 8-bit image buffer"]
    pub fn dc1394_bayer_decoding_8bit(
        bayer: *const u8,
        rgb: *mut u8,
        width: u32,
        height: u32,
        tile: dc1394color_filter_t::Type,
        method: dc1394bayer_method_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Perform de-mosaicing on an 16-bit image buffer"]
    pub fn dc1394_bayer_decoding_16bit(
        bayer: *const u16,
        rgb: *mut u16,
        width: u32,
        height: u32,
        tile: dc1394color_filter_t::Type,
        method: dc1394bayer_method_t::Type,
        bits: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Converts the format of a video frame."]
    #[doc = ""]
    #[doc = " To set the format of the output, simply set the values of the corresponding fields in the output frame"]
    pub fn dc1394_convert_frames(
        in_: *mut dc1394video_frame_t,
        out: *mut dc1394video_frame_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " De-mosaicing of a Bayer-encoded video frame"]
    #[doc = ""]
    #[doc = " To set the format of the output, simply set the values of the corresponding fields in the output frame"]
    #[doc = " @param in is a pointer to the bayer video frame that is to be converted"]
    #[doc = " @param out is a pointer to the frame to be converted to.  If there is memory allocated to the image field,"]
    #[doc = "      then it will be adjusted accordingly by this function.  If there is no memory allocated to the image"]
    #[doc = "      field, then ensure that out->image == NULL and out->allocated_image_bytes == 0"]
    #[doc = " @param method is the bayer method to interpolate the frame."]
    pub fn dc1394_debayer_frames(
        in_: *mut dc1394video_frame_t,
        out: *mut dc1394video_frame_t,
        method: dc1394bayer_method_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " De-interlacing of stereo data for cideo frames"]
    #[doc = ""]
    #[doc = " To set the format of the output, simply set the values of the corresponding fields in the output frame"]
    pub fn dc1394_deinterlace_stereo_frames(
        in_: *mut dc1394video_frame_t,
        out: *mut dc1394video_frame_t,
        method: dc1394stereo_method_t::Type,
    ) -> dc1394error_t::Type;
}
#[doc = " A struct containing information about a mode of Format_7, the scalable image format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dc1394format7mode_t {
    pub present: dc1394bool_t::Type,
    pub size_x: u32,
    pub size_y: u32,
    pub max_size_x: u32,
    pub max_size_y: u32,
    pub pos_x: u32,
    pub pos_y: u32,
    pub unit_size_x: u32,
    pub unit_size_y: u32,
    pub unit_pos_x: u32,
    pub unit_pos_y: u32,
    pub color_codings: dc1394color_codings_t,
    pub color_coding: dc1394color_coding_t::Type,
    pub pixnum: u32,
    pub packet_size: u32,
    pub unit_packet_size: u32,
    pub max_packet_size: u32,
    pub total_bytes: u64,
    pub color_filter: dc1394color_filter_t::Type,
}
#[test]
fn bindgen_test_layout___dc1394format7mode_t() {
    assert_eq!(
        ::std::mem::size_of::<__dc1394format7mode_t>(),
        128usize,
        concat!("Size of: ", stringify!(__dc1394format7mode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__dc1394format7mode_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__dc1394format7mode_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394format7mode_t>())).present as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394format7mode_t>())).size_x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(size_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394format7mode_t>())).size_y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(size_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).max_size_x as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(max_size_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).max_size_y as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(max_size_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394format7mode_t>())).pos_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(pos_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394format7mode_t>())).pos_y as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(pos_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).unit_size_x as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(unit_size_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).unit_size_y as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(unit_size_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).unit_pos_x as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(unit_pos_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).unit_pos_y as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(unit_pos_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).color_codings as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(color_codings)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).color_coding as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(color_coding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394format7mode_t>())).pixnum as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(pixnum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).packet_size as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(packet_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).unit_packet_size as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(unit_packet_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).max_packet_size as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(max_packet_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).total_bytes as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(total_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__dc1394format7mode_t>())).color_filter as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7mode_t),
            "::",
            stringify!(color_filter)
        )
    );
}
pub type dc1394format7mode_t = __dc1394format7mode_t;
#[doc = " A struct containing the list of Format_7 modes."]
#[doc = " FIXME: this may become very big if format_7 pages are used in IIDC 1.32. It would be better to use a \"num\" and an allocated list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dc1394format7modeset_t {
    pub mode: [dc1394format7mode_t; 8usize],
}
#[test]
fn bindgen_test_layout___dc1394format7modeset_t() {
    assert_eq!(
        ::std::mem::size_of::<__dc1394format7modeset_t>(),
        1024usize,
        concat!("Size of: ", stringify!(__dc1394format7modeset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__dc1394format7modeset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__dc1394format7modeset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__dc1394format7modeset_t>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__dc1394format7modeset_t),
            "::",
            stringify!(mode)
        )
    );
}
pub type dc1394format7modeset_t = __dc1394format7modeset_t;
extern "C" {
    #[doc = " Gets the maximal image size for a given mode."]
    pub fn dc1394_format7_get_max_image_size(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        h_size: *mut u32,
        v_size: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the unit sizes for a given mode. The image size can only be a multiple of the unit size, and cannot be smaller than it."]
    pub fn dc1394_format7_get_unit_size(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        h_unit: *mut u32,
        v_unit: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current image size."]
    pub fn dc1394_format7_get_image_size(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        width: *mut u32,
        height: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the current image size"]
    pub fn dc1394_format7_set_image_size(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        width: u32,
        height: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current image position"]
    pub fn dc1394_format7_get_image_position(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        left: *mut u32,
        top: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the current image position"]
    pub fn dc1394_format7_set_image_position(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        left: u32,
        top: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the unit positions for a given mode. The image position can only be a multiple of the unit position (zero is acceptable)."]
    pub fn dc1394_format7_get_unit_position(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        h_unit_pos: *mut u32,
        v_unit_pos: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current color coding"]
    pub fn dc1394_format7_get_color_coding(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        color_coding: *mut dc1394color_coding_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the list of color codings available for this mode"]
    pub fn dc1394_format7_get_color_codings(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        codings: *mut dc1394color_codings_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the current color coding"]
    pub fn dc1394_format7_set_color_coding(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        color_coding: dc1394color_coding_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current color filter"]
    pub fn dc1394_format7_get_color_filter(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        color_filter: *mut dc1394color_filter_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Get the parameters of the packet size: its maximal size and its unit size. The packet size is always a multiple of the unit bytes and cannot be zero."]
    pub fn dc1394_format7_get_packet_parameters(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        unit_bytes: *mut u32,
        max_bytes: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the current packet size"]
    pub fn dc1394_format7_get_packet_size(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        packet_size: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Sets the current packet size"]
    pub fn dc1394_format7_set_packet_size(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        packet_size: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the recommended packet size. Ignore if zero."]
    pub fn dc1394_format7_get_recommended_packet_size(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        packet_size: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the number of packets per frame."]
    pub fn dc1394_format7_get_packets_per_frame(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        ppf: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the data depth (e.g. 12, 13, 14 bits/pixel)"]
    pub fn dc1394_format7_get_data_depth(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        data_depth: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the frame interval in float format"]
    pub fn dc1394_format7_get_frame_interval(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        interval: *mut f32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the number of pixels per image frame"]
    pub fn dc1394_format7_get_pixel_number(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        pixnum: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Get the total number of bytes per frame. This includes padding (to reach an entire number of packets)"]
    pub fn dc1394_format7_get_total_bytes(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        total_bytes: *mut u64,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the properties of all Format_7 modes supported by the camera."]
    pub fn dc1394_format7_get_modeset(
        camera: *mut dc1394camera_t,
        info: *mut dc1394format7modeset_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Gets the properties of a Format_7 mode"]
    pub fn dc1394_format7_get_mode_info(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        f7_mode: *mut dc1394format7mode_t,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Joint function that fully sets a certain ROI taking all parameters into account."]
    #[doc = " Note that this function does not SWITCH to the video mode passed as argument, it mearly sets it"]
    pub fn dc1394_format7_set_roi(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        color_coding: dc1394color_coding_t::Type,
        packet_size: i32,
        left: i32,
        top: i32,
        width: i32,
        height: i32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Joint function that fully gets a certain ROI taking all parameters into account."]
    pub fn dc1394_format7_get_roi(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        color_coding: *mut dc1394color_coding_t::Type,
        packet_size: *mut u32,
        left: *mut u32,
        top: *mut u32,
        width: *mut u32,
        height: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " dc1394_iso_set_persist"]
    #[doc = " @param camera A camera handle."]
    #[doc = ""]
    #[doc = " Calling this function will cause isochronous channel and bandwidth"]
    #[doc = " allocations to persist beyond the lifetime of this dc1394camera_t"]
    #[doc = " instance.  Normally (when this function is not called), any allocations"]
    #[doc = " would be automatically released upon freeing this camera or a"]
    #[doc = " premature shutdown of the application (if possible).  For this function"]
    #[doc = " to be used, it must be called prior to any allocations or an error will"]
    #[doc = " be returned."]
    #[doc = ""]
    #[doc = " @return \\a DC1394_SUCCESS if the operation succeeded."]
    #[doc = " \\a DC1394_FUNCTION_NOT_SUPPORTED if the current platform/driver does not"]
    #[doc = " allow persistent allocations."]
    pub fn dc1394_iso_set_persist(camera: *mut dc1394camera_t) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " dc1394_iso_allocate_channel:"]
    #[doc = " @param camera A camera handle."]
    #[doc = " @param channels_allowed A bitmask of acceptable channels for the allocation."]
    #[doc = "   The LSB corresponds to channel 0 and the MSB corresponds to channel"]
    #[doc = "   63.  Only channels whose bit is set will be considered for the allocation."]
    #[doc = "   If \\a channels_allowed = 0, the complete set of channels supported by"]
    #[doc = "   this camera will be considered for the allocation."]
    #[doc = " @param channel The allocated channel number is returned here."]
    #[doc = ""]
    #[doc = " Allocates an isochronous channel.  This"]
    #[doc = " function may be called multiple times, each time allocating an additional"]
    #[doc = " channel.  The channel is automatically re-allocated if there is a bus"]
    #[doc = " reset.  The channel is automatically released when this dc1394camera_t"]
    #[doc = " is freed or if the application shuts down prematurely.  If the channel"]
    #[doc = " needs to persist beyond the lifetime of this application, call"]
    #[doc = " \\a dc1394_iso_set_persist() first.  Note that this function does _not_"]
    #[doc = " automatically program @a camera to use the allocated channel for isochronous"]
    #[doc = " streaming.  You must do that manually using \\a dc1394_video_set_iso_channel()."]
    #[doc = ""]
    #[doc = " @return \\a DC1394_SUCCESS if the operation succeeded.  The allocated"]
    #[doc = " channel is stored in \\a channel. \\a DC1394_FUNCTION_NOT_SUPPORTED if the"]
    #[doc = " current driver/platform does not allow channel allocation."]
    #[doc = " \\a DC1394_NO_ISO_CHANNEL if none of the requested channels are available."]
    pub fn dc1394_iso_allocate_channel(
        camera: *mut dc1394camera_t,
        channels_allowed: u64,
        channel: *mut ::std::os::raw::c_int,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " dc1394_iso_release_channel:"]
    #[doc = " @param camera A camera handle."]
    #[doc = " @param channel The channel number to release."]
    #[doc = ""]
    #[doc = " Releases a previously allocated channel.  It is acceptable to release"]
    #[doc = " channels that were allocated by a different process or host.  If"]
    #[doc = " attempting to release a channel that is already released, the function"]
    #[doc = " will succeed."]
    #[doc = ""]
    #[doc = " @return \\a DC1394_SUCCESS if the operation succeeded."]
    #[doc = " \\a DC1394_FUNCTION_NOT_SUPPORTED if the current driver/platform does not"]
    #[doc = " allow channel release."]
    pub fn dc1394_iso_release_channel(
        camera: *mut dc1394camera_t,
        channel: ::std::os::raw::c_int,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " dc1394_iso_allocate_bandwidth:"]
    #[doc = " @param camera A camera handle."]
    #[doc = " @param bandwidth_units The number of isochronous bandwidth units to allocate."]
    #[doc = ""]
    #[doc = " Allocates isochronous bandwidth.  This functions allocates bandwidth"]
    #[doc = " _in addition_ to any previous allocations.  It may be called multiple"]
    #[doc = " times.  The bandwidth is automatically re-allocated if there is a bus"]
    #[doc = " reset.  The bandwidth is automatically released if this camera is freed"]
    #[doc = " or the application shuts down prematurely.  If the bandwidth needs to"]
    #[doc = " persist beyond the lifetime of this application, call"]
    #[doc = " \\a dc1394_iso_set_persist() first."]
    #[doc = ""]
    #[doc = " @return \\a DC1394_SUCCESS if the operation succeeded."]
    #[doc = " \\a DC1394_FUNCTION_NOT_SUPPORTED if the current driver/platform does not"]
    #[doc = " allow bandwidth allocation. \\a DC1394_NO_BANDWIDTH if there is not enough"]
    #[doc = " available bandwidth to support the allocation.  In this case,"]
    #[doc = " no bandwidth is allocated."]
    pub fn dc1394_iso_allocate_bandwidth(
        camera: *mut dc1394camera_t,
        bandwidth_units: ::std::os::raw::c_int,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " dc1394_iso_release_bandwidth:"]
    #[doc = " @param camera A camera handle."]
    #[doc = " @param bandwidth_units The number of isochronous bandwidth units to free."]
    #[doc = ""]
    #[doc = " Releases previously allocated isochronous bandwidth.  Each \\a dc1394camera_t"]
    #[doc = " keeps track of a running total of bandwidth that has been allocated."]
    #[doc = " Released bandwidth is subtracted from this total for the sake of"]
    #[doc = " automatic re-allocation and automatic release on shutdown.  It is also"]
    #[doc = " acceptable for a camera to release more bandwidth than it has allocated"]
    #[doc = " (to clean up for another process for example).  In this case, the"]
    #[doc = " running total of bandwidth is not affected.  It is acceptable to"]
    #[doc = " release more bandwidth than is allocated in total for the bus.  In this"]
    #[doc = " case, all bandwidth is released and the function succeeds."]
    #[doc = ""]
    #[doc = " @return \\a DC1394_SUCCESS if the operation succeeded."]
    #[doc = " \\a DC1394_FUNCTION_NOT_SUPPORTED if the current driver/platform does not"]
    #[doc = " allow bandwidth release."]
    pub fn dc1394_iso_release_bandwidth(
        camera: *mut dc1394camera_t,
        bandwidth_units: ::std::os::raw::c_int,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " dc1394_iso_release_all:"]
    #[doc = " @param camera A camera handle."]
    #[doc = ""]
    #[doc = " Releases all channels and bandwidth that have been previously allocated"]
    #[doc = " for this dc1394camera_t.  Note that this information can only be tracked"]
    #[doc = " per process, and there is no knowledge of allocations for this camera"]
    #[doc = " by previous processes.  To release resources in such a case, the manual"]
    #[doc = " release functions \\a dc1394_iso_release_channel() and"]
    #[doc = " \\a dc1394_iso_release_bandwidth() must be used."]
    #[doc = ""]
    #[doc = " @return \\a DC1394_SUCCESS if the operation succeeded. \\a DC1394_FAILURE"]
    #[doc = " if some resources were not able to be released."]
    pub fn dc1394_iso_release_all(camera: *mut dc1394camera_t) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_get_registers(
        camera: *mut dc1394camera_t,
        offset: u64,
        value: *mut u32,
        num_regs: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_set_registers(
        camera: *mut dc1394camera_t,
        offset: u64,
        value: *const u32,
        num_regs: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_get_control_registers(
        camera: *mut dc1394camera_t,
        offset: u64,
        value: *mut u32,
        num_regs: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_set_control_registers(
        camera: *mut dc1394camera_t,
        offset: u64,
        value: *const u32,
        num_regs: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_get_adv_control_registers(
        camera: *mut dc1394camera_t,
        offset: u64,
        value: *mut u32,
        num_regs: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_set_adv_control_registers(
        camera: *mut dc1394camera_t,
        offset: u64,
        value: *const u32,
        num_regs: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_get_format7_register(
        camera: *mut dc1394camera_t,
        mode: ::std::os::raw::c_uint,
        offset: u64,
        value: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_set_format7_register(
        camera: *mut dc1394camera_t,
        mode: ::std::os::raw::c_uint,
        offset: u64,
        value: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_get_absolute_register(
        camera: *mut dc1394camera_t,
        feature: ::std::os::raw::c_uint,
        offset: u64,
        value: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_set_absolute_register(
        camera: *mut dc1394camera_t,
        feature: ::std::os::raw::c_uint,
        offset: u64,
        value: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_get_PIO_register(
        camera: *mut dc1394camera_t,
        offset: u64,
        value: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_set_PIO_register(
        camera: *mut dc1394camera_t,
        offset: u64,
        value: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_get_SIO_register(
        camera: *mut dc1394camera_t,
        offset: u64,
        value: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_set_SIO_register(
        camera: *mut dc1394camera_t,
        offset: u64,
        value: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_get_strobe_register(
        camera: *mut dc1394camera_t,
        offset: u64,
        value: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " No Docs"]
    pub fn dc1394_set_strobe_register(
        camera: *mut dc1394camera_t,
        offset: u64,
        value: u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Returns the image width and height (in pixels) corresponding to a video mode. Works for scalable and non-scalable video modes."]
    pub fn dc1394_get_image_size_from_video_mode(
        camera: *mut dc1394camera_t,
        video_mode: u32,
        width: *mut u32,
        height: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Returns the given framerate as a float."]
    pub fn dc1394_framerate_as_float(
        framerate_enum: dc1394framerate_t::Type,
        framerate: *mut f32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Returns the number of bits per pixel for a certain color coding. This is the size of the data sent on the bus, the effective"]
    #[doc = " data depth may vary. Example: RGB16 is 16, YUV411 is 8, YUV422 is 8."]
    pub fn dc1394_get_color_coding_data_depth(
        color_coding: dc1394color_coding_t::Type,
        bits: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Returns the bit-space used by a pixel. This is different from the data depth! For instance, RGB16 has a bit space of 48 bits,"]
    #[doc = " YUV422 is 16bits and YU411 is 12bits."]
    pub fn dc1394_get_color_coding_bit_size(
        color_coding: dc1394color_coding_t::Type,
        bits: *mut u32,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Returns the color coding from the video mode. Works with scalable image formats too."]
    pub fn dc1394_get_color_coding_from_video_mode(
        camera: *mut dc1394camera_t,
        video_mode: dc1394video_mode_t::Type,
        color_coding: *mut dc1394color_coding_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Tells whether the color mode is color or monochrome"]
    pub fn dc1394_is_color(
        color_mode: dc1394color_coding_t::Type,
        is_color: *mut dc1394bool_t::Type,
    ) -> dc1394error_t::Type;
}
extern "C" {
    #[doc = " Tells whether the video mode is scalable or not."]
    pub fn dc1394_is_video_mode_scalable(
        video_mode: dc1394video_mode_t::Type,
    ) -> dc1394bool_t::Type;
}
extern "C" {
    #[doc = " Tells whether the video mode is \"still image\" or not (\"still image\" is currently not supported by any cameras on the market)"]
    pub fn dc1394_is_video_mode_still_image(
        video_mode: dc1394video_mode_t::Type,
    ) -> dc1394bool_t::Type;
}
extern "C" {
    #[doc = " Tells whether two IDs refer to the same physical camera unit."]
    pub fn dc1394_is_same_camera(
        id1: dc1394camera_id_t,
        id2: dc1394camera_id_t,
    ) -> dc1394bool_t::Type;
}
extern "C" {
    #[doc = " Returns a descriptive name for a feature"]
    pub fn dc1394_feature_get_string(
        feature: dc1394feature_t::Type,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a descriptive string for an error code"]
    pub fn dc1394_error_get_string(error: dc1394error_t::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Calculates the CRC16 checksum of a memory region. Useful to verify the CRC of an image buffer, for instance."]
    pub fn dc1394_checksum_crc16(buffer: *const u8, buffer_size: u32) -> u16;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
